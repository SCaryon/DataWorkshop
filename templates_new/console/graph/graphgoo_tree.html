{% extends 'console/layout.html' %}
{% block product_name %}
    GraphGoo
{% endblock %}

{% block product_description %}
    Tree Layout
{% endblock %}


{% block content %}
<style>
.getdata{
    display: none;
}
</style>

<div class="section topmargin-lg nobottommargin section_product" style="margin:0px !important;">
    <div class="container clearfix">
        <div id="tree_layout">
        </div>
    </div>
</div>

<div class="getdata">
    <ul id="graph_nodes">
        {% for item in nodes %}
            <li>{{ item }}</li>
        {% endfor %}
    </ul>
    <ul id="graph_matrix">
        {% for item in matrix %}
            <li>{{ item }}</li>
        {% endfor %}
    </ul>
</div>

<script src="/static/js/d3.v3.min.js"></script>
<script>
    graph_nodes = new Array();
    arr = document.getElementById("graph_nodes").getElementsByTagName('li');
    temp = [];
    for (i = 0; i < arr.length; i++) {
        graph_nodes.push(arr[i].innerHTML);
    }
    var graph_matrix = new Array();
    arr = document.getElementById('graph_matrix').getElementsByTagName('li');
    temp = [];
    for (i = 0; i < arr.length; i++) {
        temp.push(arr[i].innerHTML)
    }
    for (i = 0; i < temp.length; i++) {
        temp1 = temp[i].replace('[', '');
        temp2 = temp1.replace(']', '');
        temp3 = temp2.split(",");
        numArray = temp3.map((value) => {
            return parseFloat(value);
        });
        graph_matrix.push(numArray)
    }
    tree_degree = [];
    for(i = 0; i < graph_matrix.length; i++){
        tree_degree.push(0);
    }
    for(i = 0; i < graph_matrix.length; i++){
        for(j = i + 1; j < graph_matrix.length; j++){
            if(!isNaN(graph_matrix[i][j])){
                tree_degree[i]++;
                tree_degree[j]++;
            }
        }
    }
    tree_root = 0;
    for(i = 0; i < tree_degree.length; i++){
        if(tree_degree[i] > tree_degree[tree_root]){
            tree_root = i;
        }
    }

    var tree_margin = [20, 120, 20, 20],
    tree_width = 1280 - tree_margin[1] - tree_margin[3],
    tree_height = 800 - tree_margin[0] - tree_margin[2],
    tree_i = 0,
    tree_layout2root;

var tree = d3.layout.tree()
    .size([tree_height, tree_width]);

var tree_diagonal = d3.svg.diagonal()
    .projection(function(d) { return [d.y, d.x]; });

var tree_svg = d3.select("#tree_layout").append("svg:svg")
    .attr("width", tree_width + tree_margin[1] + tree_margin[3])
    .attr("height", tree_height + tree_margin[0] + tree_margin[2])
    .call(tree_zoom = d3.behavior.zoom().scaleExtent([0.5,20]).on("zoom", tree_redraw))
  .append("svg:g")
    .attr("transform", "translate(" + tree_margin[3] + "," + tree_margin[0] + ")");

tree_zoom.translate([350, 20]);
tree_layout2root = get_tree_data(tree_root, -1);
tree_layout2root.x0 = tree_height / 2;
tree_layout2root.y0 = 0;

function tree_toggleAll(d) {
  if (d.children) {
    d.children.forEach(tree_toggleAll);
    tree_toggle(d);
  }
}

  // Initialize the display to show a few nodes.
  // tree_layout2root.children.forEach(tree_toggleAll);
  // toggle(tree_layout2root.children[1]);
  // toggle(tree_layout2root.children[1].children[2]);
  // toggle(tree_layout2root.children[9]);
  // toggle(tree_layout2root.children[9].children[0]);

 tree_update(tree_layout2root);


function tree_update(source) {
  var duration = d3.event && d3.event.altKey ? 5000 : 500;

  // Compute the new tree layout.
  var nodes = tree.nodes(tree_layout2root).reverse();

  // Normalize for fixed-depth.
  nodes.forEach(function(d) { d.y = d.depth * 180; });

  // Update the nodes…
  var node = tree_svg.selectAll("g.node")
      .data(nodes, function(d) { return d.id || (d.id = ++tree_i); });

  // Enter any new nodes at the parent's previous position.
  var nodeEnter = node.enter().append("svg:g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
      .on("click", function(d) { tree_toggle(d); tree_update(d); });

  nodeEnter.append("svg:circle")
      .attr("r", 1e-6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; })
      .attr('fill', '#fff')
      .attr('stroke', 'steelblue')
      .attr('stroke-width', '1.5px')
      .attr('cursor', 'pointer');

  nodeEnter.append('a')
      .attr('xlink:href', function(d) {
        return d.url;
      })
      .append("svg:text")
      .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
      .attr("dy", ".35em")
      .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
      .text(function(d) { return d.name; })
      .style('fill', function(d) {
        return d.free ? 'black' : '#999';
      })
      .attr('font-size', '12px')
      .style("fill-opacity", 1e-6);

  /*nodeEnter.append("svg:title")
    .text(function(d) {
      return d.description;
    });*/

  // Transition nodes to their new position.
  var nodeUpdate = node.transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

  nodeUpdate.select("circle")
      .attr("r", 6)
      .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

  nodeUpdate.select("text")
      .style("fill-opacity", 1);

  // Transition exiting nodes to the parent's new position.
  var nodeExit = node.exit().transition()
      .duration(duration)
      .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
      .remove();

  nodeExit.select("circle")
      .attr("r", 1e-6);

  nodeExit.select("text")
      .style("fill-opacity", 1e-6);

  // Update the links…
  var link = tree_svg.selectAll("path.link")
      .data(tree.links(nodes), function(d) { return d.target.id; });

  // Enter any new links at the parent's previous position.
  link.enter().insert("svg:path", "g")
      .attr("class", "link")
      .attr('fill', 'none')
      .attr('stroke', '#ccc')
      .attr('stroke-width', '2.0px')
      .attr("d", function(d) {
        var o = {x: source.x0, y: source.y0};
        return tree_diagonal({source: o, target: o});
      })
    .transition()
      .duration(duration)
      .attr("d", tree_diagonal);

  // Transition links to their new position.
  link.transition()
      .duration(duration)
      .attr("d", tree_diagonal);

  // Transition exiting nodes to the parent's new position.
  link.exit().transition()
      .duration(duration)
      .attr("d", function(d) {
        var o = {x: source.x, y: source.y};
        return tree_diagonal({source: o, target: o});
      })
      .remove();

  // Stash the old positions for transition.
  nodes.forEach(function(d) {
    d.x0 = d.x;
    d.y0 = d.y;
  });
}

// Toggle children.
function tree_toggle(d) {
  if (d.children) {
    d._children = d.children;
    d.children = null;
  } else {
    d.children = d._children;
    d._children = null;
  }
}

function tree_redraw() {
  //console.log("here", d3.event.translate, d3.event.scale);
  tree_svg.attr("transform",
      "translate(" + d3.event.translate + ")"
      + " scale(" + d3.event.scale + ")");
}

function get_tree_data(n, p){
        var object={};
        object.name=graph_nodes[n];
        if(p == -1){
            object.parent = "null";
        }
        else{
            object.parent = graph_nodes[p]
        }
        var cn = 0;
        for(var j = n + 1; j < graph_nodes.length; j++){
            if(!isNaN(graph_matrix[n][j])){
                cn++;
            }
        }
        if(!cn){
            object.size = Math.floor(Math.random() * 1000 + 1);
		    return object;
        }
	    var children = [];
	    for(var j = n + 1; j < graph_nodes.length; j++){
		    if(!isNaN(graph_matrix[n][j])){
			    var sub_object = get_tree_data(j, n);
			    children.push(sub_object);
		    }
	    }
	    object.children = children;
	    return object;
    }
</script>
{% endblock %}